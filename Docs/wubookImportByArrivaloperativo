// /api/wubookImportByArrival.js
// OBJETIVO: Endpoint unificado para importar reservas por fecha de llegada (arrival).
// COMPORTAMIENTO INTELIGENTE:
// 1. Si se provee 'fromDate', usa el rango especificado (para importaciones históricas).
// 2. Si NO se provee 'fromDate', calcula automáticamente 'mañana' y 'pasado mañana' (para sincronización futura).

import axios from 'axios';
import qs from 'qs';
import { firestore, Timestamp } from '../lib/firebaseAdmin.js';
import { DateTime } from 'luxon';

// ===================== CONFIGURACIÓN Y UTILIDADES =====================
const log = (...args) => console.log(`[ImportByArrival]`, ...args); // Nuevo prefijo de log
const TZ = 'America/Argentina/Buenos_Aires';
const BASE_URL = process.env.WUBOOK_BASE_URL || 'https://kapi.wubook.net/kp';
const parseEU = (s) => DateTime.fromFormat(s, 'dd/LL/yyyy', { zone: TZ });
const euToISO = (s) => (s ? parseEU(s).toISODate() : null);

// ... (Las funciones ok, bad, fetchReservationsByFilter, getPropertiesAndRoomMaps, y processAndSaveReservations son idénticas y no necesitan cambios)

// ---- Respuestas HTTP ----
function ok(res, data) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(200).json(data);
}
function bad(res, code, error) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(code).json({ error });
}

// ---- WuBook: fetch con paginación ----
async function fetchReservationsByFilter({ apiKey, filters }) {
  const headers = { 'x-api-key': apiKey, 'Content-Type': 'application/x-www-form-urlencoded' };
  const limit = 64; let offset = 0; let hasMore = true; const allReservations = []; let guard = 0;
  log('Iniciando fetch paginado con filtros:', filters);
  while (hasMore) {
    guard++; if (guard > 100) { log('WARN: Failsafe guard triggered.'); break; }
    const payload = qs.stringify({ filters: JSON.stringify({ ...filters, pager: { limit, offset } }) });
    log(`WuBook POST /reservations/fetch_reservations | Página: ${guard}, Offset: ${offset}`);
    try {
      const resp = await axios.post(`${BASE_URL}/reservations/fetch_reservations`, payload, { headers });
      const items = resp?.data?.data?.reservations || [];
      allReservations.push(...items);
      hasMore = items.length === limit;
      offset += limit;
    } catch (error) { log('WuBook API Error:', error.response ? error.response.data : error.message); hasMore = false; }
  }
  log(`Fetch finalizado. Total de reservas encontradas: ${allReservations.length}`);
  return allReservations;
}

// ---- Firestore: leer propiedades y mapeo de rooms ----
async function getPropertiesAndRoomMaps(propertyIds) {
    const propsCol = firestore.collection('propiedades');
    let propDocs = [];
    if (Array.isArray(propertyIds) && propertyIds.length) {
        const snaps = await Promise.all(propertyIds.map((id) => propsCol.doc(id).get()));
        propDocs = snaps.filter((s) => s.exists);
    } else { const snap = await propsCol.get(); propDocs = snap.docs; }
    const list = [];
    for (const d of propDocs) {
        const data = d.data();
        const apiKey = data?.api_key || data?.integraciones?.wubook_apiKey || data?.integraciones?.wubook?.apiKey;
        if (!apiKey) continue;
        const roomMap = new Map();
        const depsSnap = await d.ref.collection('departamentos').get();
        depsSnap.forEach(dep => {
            const v = dep.data(); const idZak = dep.id;
            const codigo_depto = v?.codigo_depto || v?.wubook_shortname || dep.id;
            const nombre_depto = v?.nombre || v?.name || '';
            roomMap.set(idZak, { codigo_depto, nombre_depto });
        });
        log('Mapeo de Departamentos para', { propId: d.id, count: roomMap.size });
        list.push({ id: d.id, nombre: data?.nombre || d.id, apiKey, roomMap });
    }
    return list;
}

// ---- Función para procesar y guardar un lote de reservas ----
async function processAndSaveReservations(reservas, prop, dryRun) {
    if (!reservas || reservas.length === 0) return { upserts: 0, skipped: 0 };
    log(`Procesando ${reservas.length} reservas para la propiedad ${prop.id}`);
    const batch = firestore.batch(); const now = Timestamp.now(); let upserts = 0, skipped = 0;
    for (const r of reservas) {
        const fullName = `${r?.customer?.name || ''} ${r?.customer?.surname || ''}`.trim() || String(r?.booker) || 'N/D';
        let sourceChannel = r?.channel_name || 'Directo/WuBook';
        if (r?.origin?.channel && r?.origin.channel !== '--') sourceChannel = r.origin.channel;
        for (const room of r?.rooms || []) {
            const idZak = String(room?.id_zak_room || room?.id_zak_room_type || '');
            const mapData = prop.roomMap.get(idZak);
            if (!idZak || !mapData) { skipped++; continue; }
            const { codigo_depto, nombre_depto } = mapData;
            const arrivalEU = room?.arrival || room?.dfrom || r?.arrival || r?.dfrom || null;
            const departureEU = room?.departure || room?.dto || r?.departure || r?.dto || null;
            if (!arrivalEU || !departureEU) { skipped++; continue; }
            const docId = `${prop.id}_${r.id_human}_${idZak}`;
            const ref = firestore.collection('Reservas').doc(docId);
            const doc = {
                id_human: r.id_human, 
                propiedad_id: prop.id, 
                propiedad_nombre: prop.nombre,
                nombre_huesped: fullName, 
                source: sourceChannel, 
                id_zak: idZak, 
                codigo_depto,
                depto_nombre: nombre_depto || null, 
                arrival: arrivalEU, 
                arrival_iso: euToISO(arrivalEU),
                departure: departureEU, 
                departure_iso: euToISO(departureEU), 
                adults: room?.occupancy?.adults ?? r?.adults ?? null,
                children: room?.occupancy?.children ?? r?.children ?? 0,
                status: r?.status || 'unknown', // Guardamos el estado de la reserva (ej: 'CONFIRMED', 'CANCELLED') 
                updatedAt: now, 
                createdAt: now
            };
            batch.set(ref, doc, { merge: true });
            upserts++;
        }
    }
    if (!dryRun && upserts > 0) {
        log('BATCH COMMIT', { propId: prop.id, upserts, skipped });
        await batch.commit();
    } else { log('DRY RUN o sin cambios', { propId: prop.id, upserts, skipped, dryRun }); }
    return { upserts, skipped };
}


// ===================== HANDLER PRINCIPAL (CON LÓGICA INTELIGENTE) =====================
export default async function handler(req, res) {
  if (req.method === 'OPTIONS') return ok(res, { ok: true });
  // Permitimos GET para que los crons puedan llamarlo fácilmente sin body.
  if (req.method !== 'POST' && req.method !== 'GET') return bad(res, 405, 'Método no permitido');

  try {
    const { propertyIds, dryRun = false } = (req.body && req.method === 'POST') ? req.body : {};
    let { fromDate, toDate } = (req.body && req.method === 'POST') ? req.body : {};
    let mode = 'manual';

    // ========= NUEVA LÓGICA INTELIGENTE =========
    if (!fromDate) {
        mode = 'auto_future_sync'; // Estamos en modo automático
        const now = DateTime.now().setZone(TZ);
        fromDate = now.plus({ days: 1 }).toFormat('dd/LL/yyyy'); // Mañana
        toDate = now.plus({ days: 2 }).toFormat('dd/LL/yyyy');   // Pasado mañana
        log(`Modo automático: no se proveyó 'fromDate'. Usando rango calculado: ${fromDate} - ${toDate}`);
    } else if (!toDate) {
        toDate = '31/12/2099'; // Comportamiento por defecto para importación histórica abierta
    }
    // ===========================================

    log('INIT', { mode, fromDate, toDate, propertyIds, dryRun });
    
    const propiedades = await getPropertiesAndRoomMaps(propertyIds);
    if (!propiedades.length) return bad(res, 400, 'No se encontraron propiedades con api_key válidas.');
    
    const summary = [];

    for (const prop of propiedades) {
      log('PROP START', { id: prop.id, nombre: prop.nombre });
      const reservas = await fetchReservationsByFilter({
        apiKey: prop.apiKey,
        filters: { arrival: { from: fromDate, to: toDate } }
      });
      const { upserts, skipped } = await processAndSaveReservations(reservas, prop, dryRun);
      summary.push({ propiedad: { id: prop.id, nombre: prop.nombre }, mode, range: { from: fromDate, to: toDate }, total_found: reservas.length, upserts, skipped, dryRun });
      log('PROP DONE', summary[summary.length - 1]);
    }

    log('DONE');
    return ok(res, { ok: true, summary });
  } catch (err) {
    log('ERROR', err?.message); console.error(err);
    return bad(res, 500, err?.message || 'Error interno');
  }
}