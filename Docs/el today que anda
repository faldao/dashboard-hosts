// /api/wubookSyncToday.js
// OBJETIVO: Sincronizar las reservas del día (llegadas, salidas, alojados).
// Utiliza el endpoint 'fetch_today_reservations' de WuBook, que es muy eficiente.
// Diseñado para ser ejecutado por un cron cada hora.

import axios from 'axios';
import qs from 'qs';
import { firestore, Timestamp } from '../lib/firebaseAdmin.js';
import { DateTime } from 'luxon';

// ===================== CONFIGURACIÓN Y UTILIDADES =====================
const log = (...args) => console.log(`[SyncToday]`, ...args);
const TZ = 'America/Argentina/Buenos_Aires';
const BASE_URL = process.env.WUBOOK_BASE_URL || 'https://kapi.wubook.net/kp';
const parseEU = (s) => DateTime.fromFormat(s, 'dd/LL/yyyy', { zone: TZ });
const euToISO = (s) => (s ? parseEU(s).toISODate() : null);

// ---- Respuestas HTTP ----
function ok(res, data) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(200).json(data);
}
function bad(res, code, error) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(code).json({ error });
}

// ---- Firestore: leer propiedades y mapeo de rooms ----
async function getPropertiesAndRoomMaps(propertyIds) {
  const propsCol = firestore.collection('propiedades');
  let propDocs = [];
  if (Array.isArray(propertyIds) && propertyIds.length) {
    const snaps = await Promise.all(propertyIds.map((id) => propsCol.doc(id).get()));
    propDocs = snaps.filter((s) => s.exists);
  } else {
    const snap = await propsCol.get();
    propDocs = snap.docs;
  }
  const list = [];
  for (const d of propDocs) {
    const data = d.data();
    const apiKey = data?.api_key || data?.integraciones?.wubook_apiKey || data?.integraciones?.wubook?.apiKey;
    if (!apiKey) { continue; }
    const roomMap = new Map();
    const depsSnap = await d.ref.collection('departamentos').get();
    for (const dep of depsSnap.docs) {
      const v = dep.data(); const idZak = dep.id;
      const codigo_depto = v?.codigo_depto || v?.wubook_shortname || dep.id;
      const nombre_depto = v?.nombre || v?.name || '';
      roomMap.set(idZak, { codigo_depto, nombre_depto });
    }
    log('Mapeo de Departamentos para', { propId: d.id, count: roomMap.size });
    list.push({ id: d.id, nombre: data?.nombre || d.id, apiKey, roomMap });
  }
  return list;
}

// ===================== HANDLER PRINCIPAL =====================
export default async function handler(req, res) {
  // Permitimos GET para que los crons puedan llamarlo fácilmente sin un body.
  if (req.method === 'OPTIONS') return ok(res, { ok: true });
  if (req.method !== 'POST' && req.method !== 'GET') return bad(res, 405, 'Método no permitido');

  try {
    const { propertyIds, dryRun = false } = (req.body && req.method === 'POST') ? req.body : {};
    log('INIT', { propertyIds, dryRun });

    const propiedades = await getPropertiesAndRoomMaps(propertyIds);
    if (!propiedades.length) { return bad(res, 400, 'No se encontraron propiedades con api_key de WuBook.'); }

    const summary = [];
    for (const prop of propiedades) {
      log('PROP START', { id: prop.id, nombre: prop.nombre, roomsMapped: prop.roomMap.size });
      let reservas = [];
      try {
        const payload = qs.stringify({});
        const headers = { 'x-api-key': prop.apiKey, 'Content-Type': 'application/x-www-form-urlencoded' };
        log(`WuBook POST ${BASE_URL}/reservations/fetch_today_reservations`);
        const resp = await axios.post(`${BASE_URL}/reservations/fetch_today_reservations`, payload, { headers });
        reservas = resp?.data?.data?.reservations || [];
      } catch (error) { log('WuBook API Error en fetch_today_reservations:', error.response ? error.response.data : error.message); }

      log('Reservas encontradas con fetch_today_reservations', { propId: prop.id, total: reservas.length });

      if (dryRun) {
        const sample_ids = reservas.slice(0, 5).map(r => r.id_human);
        summary.push({ propiedad: { id: prop.id, nombre: prop.nombre }, found_today: reservas.length, dryRun: true, sample_ids });
        log('DRY RUN: Finalizando después de la consulta.', summary[summary.length - 1]);
        continue;
      }

      const batch = firestore.batch(); const now = Timestamp.now(); let upserts = 0; let skipped = 0;
      for (const r of reservas) {
        const fullName = `${r?.customer?.name || ''} ${r?.customer?.surname || ''}`.trim() || String(r?.booker) || 'N/D';
        let sourceChannel = r?.channel_name || 'Directo/WuBook';
        if (r?.origin?.channel && r.origin.channel !== '--') { sourceChannel = r.origin.channel; }

        for (const room of r?.rooms || []) {
            const idZak = String(room?.id_zak_room || room?.id_zak_room_type || '');
            const mapData = prop.roomMap.get(idZak);
            if (!idZak || !mapData) { skipped++; continue; }

            const { codigo_depto, nombre_depto } = mapData;
            const arrivalEU = room?.arrival || room?.dfrom || r?.arrival || r?.dfrom || null;
            const departureEU = room?.departure || room?.dto || r?.departure || r?.dto || null;
            if (!arrivalEU || !departureEU) { skipped++; continue; }

            const docId = `${prop.id}_${r.id_human}_${idZak}`;
            const ref = firestore.collection('Reservas').doc(docId);
            const doc = {
                id_human: r.id_human, propiedad_id: prop.id, propiedad_nombre: prop.nombre,
                nombre_huesped: fullName, source: sourceChannel, id_zak: idZak, codigo_depto,
                depto_nombre: nombre_depto || null, arrival: arrivalEU, arrival_iso: euToISO(arrivalEU),
                departure: departureEU, departure_iso: euToISO(departureEU), adults: room?.occupancy?.adults ?? r?.adults ?? null,
                children: room?.occupancy?.children ?? r?.children ?? 0, updatedAt: now, createdAt: now,
            };
            batch.set(ref, doc, { merge: true });
            upserts++;
        }
      }

      if (upserts > 0) {
        log('BATCH COMMIT', { propId: prop.id, upserts, skipped });
        await batch.commit();
      } else { log('Sin cambios para commitear', { propId: prop.id, upserts, skipped }); }

      summary.push({ propiedad: { id: prop.id, nombre: prop.nombre }, found_today: reservas.length, upserts, skipped, dryRun });
      log('PROP DONE', summary[summary.length - 1]);
    }

    log('DONE');
    return ok(res, { ok: true, summary });
  } catch (err) {
    log('ERROR', err?.message); console.error(err);
    return bad(res, 500, err?.message || 'Error interno');
  }
}
